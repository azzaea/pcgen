#' Causal inference with genetic effects
#'
#' Reconstruction of directed networks with random genetic effects, based on
#' phenotypic observations. The pcgen algorithm is a modification of the
#' pc-stable algorithm of Colombo & Maathuis (2014) . It works with and without
#' replicates, assuming independent genetic effects.
#'
#' The \code{pcgen} function is based on the \code{pc} function from the pcalg
#' package (Kalisch et al. (2012) and Hauser and Buhlmann (2012)), with a
#' different conditional independence test (see pcgenTest), as well as modified
#' orientation rules.
#'
#' Some parameters from the original pc function are fixed here: skel.method =
#' "stable", u2pd = "relaxed", conservative = FALSE, maj.rule = TRUE and
#' solve.confl = TRUE, while the user can set the "NAdelete" parameter (defaults
#' to FALSE). Labels (defining the names of the nodes of the graph) is derived
#' from the data-frame suffStat, containing the data
#'
#' pcgen requires phenotypic observations on multiple traits, measured on the
#' same samples. The current implementation extends the genetic relatedness
#' matrix definition from K = Z Z^t, Z being the incidence matrix assigning
#' plants to genotypes (as is common in plants data) to a a marker-based
#' relatedness matrix definition (appropriate for human data).
#'
#' The test for conditional independence between Yj and Yk given a set of traits
#' YS can be based either on a bivariate mixed model (put res.cor = NULL) or on
#' partial correlations among the residuals. In the latter case, res.cor should
#' be the correlation matrix of the residuals, obtained with getResiduals.
#'
#' @references * Kruijer, W., Behrouzi, P., Bustos-Korts, D., Rodríguez-Álvarez,
#'   M. X., Mahmoudi, S. M., Yandell, B., ... & van Eeuwijk, F. A. (2020).
#'   Reconstruction of networks with direct and indirect genetic effects.
#'   \emph{Genetics}, 214(4), 781-807.
#' @references * Colombo, D. and Maathuis, M.H., 2014. Order-independent
#'   constraint-based causal structure learning. \emph{The Journal of Machine
#'   Learning Research}, 15(1), pp.3741-3782.
#' @references * Kalisch, M., Machler, M., Colombo, D., Maathuis, M.H. and
#'   Buhlmann, P., 2012. Causal inference using graphical models with the R
#'   package pcalg. \emph{Journal of Statistical Software}, 47(11), pp.1-26.
#' @references  *  Hauser, A. and Buhlmann, P., 2012. Characterization and
#'   greedy learning of interventional Markov equivalence classes of directed
#'   acyclic graphs. Journal of Machine Learning Research, 13(Aug),
#'   pp.2409-2464.
#'
#' @param suffStat A data.frame, of which the first column is the factor G
#'   (genotype, i.e samples' IDs) and subsequent columns contain the traits, and
#'   optionally some QTLs. The name of the first column should be G. Should not
#'   contain covariates.
#'
#' @author Willem Kruijer and Pariya Behrouzi. Maintainers: Willem Kruijer
#'   \email{willem.kruijer@wur.nl} and Pariya Behrouzi
#'   \email{pariya.behrouzi@gmail.com}
#'
#' @param covariates A data.frame containing covariates that should always be
#'   used in each conditional independence test. Should be either \code{NULL}
#'   (default) or a data.frame with the same number of rows as \code{suffStat}.
#'   An intercept is already included for each trait in suffStat; covariates
#'   should not contain a column of ones.
#'
#' @param QTLs Column numbers in \code{suffStat} that correspond to QTLs. These
#'   may be partly in S and x and y, but x and y cannot be both QTLs.
#'
#' @param K The genetic relatedness matrix. If NULL (the default), independent
#'   genetic effects are assumed.
#'
#' @param alpha The significance level used in each conditional independence
#'   test. Default is 0.01
#'
#' @param m.max Maximum size of the conditioning sets.
#'
#' @param fixedEdges A logical matrix of dimension \eqn{(p+1) \times (p+1)},
#'   where \eqn{p} is the number of traits. The first row and column refer to
#'   the genotype node G, and subsequent rows and columns to the traits. As in
#'   the pcalg package, the edge \eqn{i - j} is never considered for removal if
#'   the entry \eqn{[i, j]} or \eqn{[j, i]} (or both) are \code{TRUE}. In that
#'   case, the edge is guaranteed to be present in the resulting graph.
#'
#' @param fixedGaps  A logical matrix of dimension \eqn{(p+1) \times (p+1)},
#'   where \eqn{p} is the number of traits. The first row and column refer to
#'   the genotype node G, and subsequent rows and columns to the traits. As in
#'   the pcalg package, the edge \eqn{i - j} is removed before starting the
#'   algorithm if the entry \eqn{[i, j]} or \eqn{[j, i]} (or both) are
#'   \code{TRUE}. In that case, the edge is guaranteed to be absent in the
#'   resulting graph.
#'
#' @param verbose If \code{TRUE}, p-values for the conditional independence
#'   tests are printed
#'
#' @param use.res If \code{TRUE}, the test for conditional independence of 2
#'   traits given a set of other traits and \eqn{G} is based on residuals from
#'   GBLUP. If \code{FALSE} (the default), it is based on bivariate mixed
#'   models.
#'
#' @param res.cor If \code{use.res = TRUE}, \code{res.cor} should be the
#'   correlation matrix of the residuals of the GBLUP- the residuals can be
#'   obtained using the \code{getResiduals} function. If \code{res.cor} is
#'   provided, it is based on partial correlations among the residuals, tested
#'   using the gaussCItest function from pcalg. In case \code{res.cor} is
#'   \code{NULL} (the default), the test for conditional independence between Yj
#'   and Yk given a set of traits YS is based on a bivariate mixed model.
#'
#' @param max.iter Maximum number of iterations in the EM-algorithm, used to fit
#'   the bivariate mixed model (when \code{use.res = FALSE)}.
#'
#' @param stop.if.significant If \code{TRUE}, the EM-algorithm used in some of
#'   the conditional independence tests (when \code{use.res = FALSE}) will be
#'   stopped whenever the p-value becomes significant, i.e. below \code{alpha}.
#'   This will speed up calculations, and can be done because (1) the PC
#'   algorithm only needs an accept/reject decision (2) In EM the likelihood is
#'   nondecreasing. Should be put to \code{FALSE} if the precise p-values are of
#'   interest.
#'
#' @param NAdelete Logical, and is the NAdelete option in pcalg::pc function:
#'   TRUE deletes the edge corresponding to the conditional independence test
#'   when it returns NA. Default is FALSE
#'
#' @param return.pvalues If \code{TRUE}, the maximal p-value for each edge is
#'   returned.
#'
#' @return If \code{return.pvalues = FALSE}, the output is a graph (an object
#'   with S3 class \code{"pcgen"}). If \code{return.pvalues = TRUE}, the output
#'   is a list with elements \code{gr} (the graph) and \code{pMax} (a matrix
#'   with the p-values).
#'
#' @seealso \code{\link{getResiduals}}
#'
#' @examples
#' \dontrun{
#' data(simdata)
#' out <- pcgen(simdata)
#' rs <- getResiduals(suffStat = simdata)
#' pc.fit1 <- pcgen(suffStat = simdata, alpha = 0.01, verbose = TRUE,
#'                  use.res = TRUE, res.cor = cor(rs))
#' }
#' @export
#'
pcgen <-
  function (suffStat, covariates = NULL, QTLs = integer(), K = NULL, alpha = 0.01,
            m.max = Inf,  fixedEdges = NULL, fixedGaps = NULL, verbose = FALSE,
            use.res = FALSE, res.cor = NULL, max.iter = 50,
            stop.if.significant = TRUE, NAdelete = FALSE, return.pvalues = FALSE) {
    # pcalg::pc options for order-independt network construction

    u2pd <- c("relaxed", "rand", "retry")[1]
    skel.method <- c("stable", "original", "stable.fast")[1]
    conservative <- FALSE
    maj.rule <- TRUE
    solve.confl <- TRUE

    cl <- match.call()
    if (is.null(alpha)) alpha = 0.01
    if (!is.null(covariates)) {
      covariates <- as.data.frame(covariates)
      stopifnot(nrow(covariates)==nrow(suffStat))
    }

    if (colnames(suffStat)[1]!='G')
      stop('The first column of suffStat should be named G (genotype)')
    if (class(QTLs)!='integer')
      stop('QTLs should be a vector of integers')
    if (1 %in% QTLs)
      stop('QTLs should not contain the genotype column (G)')

    if (length(QTLs) > 0) {
      non.collider.nodes <- c(1,sort(QTLs))
    } else {
      non.collider.nodes <- 1
    }

    ###

    labels <- colnames(suffStat)
    p      <- ncol(suffStat)

    # Azza: what do these 2 lines do?
    #u2pd <- match.arg(u2pd)
    #skel.method <- match.arg(skel.method)

    # Azza: Was there a version were these options were allowed to vary?
    # They are moot as is now!
    if (u2pd != "relaxed") {
      if (conservative || maj.rule)
        stop("Conservative PC and majority rule PC can only be run with 'u2pd = relaxed'")
      if (solve.confl)
        stop("Versions of PC using lists for the orientation rules (and possibly bi-directed edges)\n can only be run with 'u2pd = relaxed'")
    }

    if (conservative && maj.rule) stop("Choose either conservative PC or majority rule PC!")

    ##################################
    # The following chunk is (i) not in the original pcalg function
    #                        (ii) ALSO in the skeleton2 function
    #                             (which now can also deal with QTLs by itself)

    #if (is.null(fixedEdges)) {
    #  stopifnot(identical(dim(fixedEdges), c(p, p)))
    #}

    #if (is.null(fixedGaps)) {
    #  gapMatrix <- matrix(FALSE, p, p)
    #} else {
    #  #stopifnot(identical(dim(fixedGaps), c(p, p)))
    #  stopifnot(identical(dim(fixedGaps), c(p, p)))
    #  gapMatrix <- as.matrix(fixedGaps)
    #}

    #if (length(QTLs) > 0) {
    #  gapMatrix[c(1,QTLs),c(1,QTLs)] <- TRUE
    #}

    #fixedGaps <- gapMatrix

    ##########################

    #skel.out <-
    skel <- skeleton2(suffStat = suffStat, alpha = alpha, labels = labels, p = p,
                      method = skel.method, m.max = m.max, fixedGaps = fixedGaps,
                      fixedEdges = fixedEdges, NAdelete = NAdelete,
                      verbose = verbose, covariates=covariates, QTLs = QTLs, K = K, #dec?
                      max.iter = max.iter, stop.if.significant = stop.if.significant,
                      use.res = use.res, res.cor = res.cor)
    ##16-1-18## : added Vg = Vg, Ve = Ve, dec = dec


    #genVar <- skel[['genVar']]
    #qtlVar <- skel[['qtlVar']]
    #skel   <- skel[['skel.out']]

    skel@call <- cl

    if (!conservative && !maj.rule) {
      # this option can not occur, at least for the moment
      gr <- switch(u2pd, rand = udag2pdag(skel),
                   retry = udag2pdagSpecial(skel)$pcObj,
                   relaxed = udag2pdagRelaxed2(skel, verbose = verbose,
                                               solve.confl = solve.confl,
                                               non.collider.nodes = non.collider.nodes))

    } else {

      pc. <- pc.cons.intern2(skel, suffStat = suffStat, alpha = alpha,
                             version.unf = c(2, 1), maj.rule = maj.rule,
                             verbose = verbose,
                             covariates = covariates, K = K,
                             QTLs = QTLs, max.iter = max.iter,
                             stop.if.significant = stop.if.significant,
                             use.res = use.res, res.cor = res.cor)

      gr <- udag2pdagRelaxed2(pc.$sk, verbose = verbose,
                              unfVect = pc.$unfTripl,
                              solve.confl = solve.confl,
                              non.collider.nodes = non.collider.nodes)

    }

    if (return.pvalues == TRUE) {
      return(list(gr = gr, pMax = skel@pMax))
    } else {
      return(gr)
    }
  }

